[[_maintaining_gh_project]]
=== Perawatan Sebuah Proyek

Sekarang setelah kita berkontribusi dalam sebuah proyek, mari kita lihat sisi lain: membuat, merawat dan mengelola proyek Anda sendiri.

==== Membuat Repositori Baru

Mari kita membuat repositori baru untuk berbagi kode proyek.
Mulailah dengan mengklik tombol ``New repository'' di sisi kanan dasbor, atau dari tombol `+` di toolbar atas di sebelah nama pengguna Anda seperti yang terlihat di <<_new_repo_dropdown>>.

.The ``Your repositories'' area.
image::images/newrepo.png[The ``Your repositories'' area.]

[[_new_repo_dropdown]]
.The ``New repository'' dropdown.
image::images/new-repo.png[The ``new repository'' dropdown.]

Ini membawa Anda ke formulir ``new repository'':

.The ``new repository'' form.
image::images/newrepoform.png[The ``new repository'' form.]

Yang harus Anda lakukan di sini adalah memberikan nama proyek; sisa field yang lain sepenuhnya tambahan.
Untuk saat ini, cukup klik tombol ``Create Repository'', dan berhasil – Anda memiliki repositori baru di GitHub, bernama `<user>/<project_name>`.

Karena Anda belum memiliki kode, GitHub akan menunjukkan petunjuk bagaimana membuat repositori Git yang baru, atau menghubungkan ke proyek Git yang ada.
Kita tidak akan mengulangi hal ini di sini; jika Anda membutuhkan penyegaran, cek di <<_git_basics_chapter>>.

Setelah proyek Anda di-host-kan di GitHub, Anda dapat memberikan URL kepada siapa pun yang ingin Anda bagikan proyek Anda.
Setiap proyek di GitHub dapat diakses melalui HTTP sebagai `https://github.com/<user>/<project_name>`, dan lebih dari SSH sebagai `git@github.com:<user>/<project_name>`.
Git dapat diambil dari dan di-push ke kedua URL ini, namun akses terkontrol berdasarkan kepercayaan pengguna yang terhubung dengannya.

[NOTE]
====
Hal ini sering lebih baik untuk berbagi URL berbasis HTTP untuk proyek publik, karena pengguna tidak harus memiliki akun GitHub untuk mengaksesnya untuk kloning. Pengguna harus memiliki akun dan kunci SSH yang diupload untuk mengakses proyek Anda jika Anda memberi mereka URL SSH. URL HTTP juga sama persis dengan URL yang akan mereka tempel ke browser untuk melihat proyek di sana.
====

==== Menambah Kolaborator

Jika Anda bekerja dengan orang lain yang ingin Anda beri akses commit, Anda perlu menambahkannya sebagai ``collaborators''.
Jika Ben, Jeff, dan Louise mendaftar ke akun GitHub, dan Anda ingin memberi mereka akses push ke repositori Anda, Anda dapat menambahkannya ke proyek Anda.
Dengan melakukan hal ini akan memberi mereka akses ``push'', yang berarti keduanya memiliki akses baca dan tulis ke proyek dan repositori Git.

Klik tautan ``Settings'' di bagian bawah sidebar kanan.

.The repository settings link.
image::images/reposettingslink.png[The repository settings link.]

Kemudian pilih ``Collaborators'' dari menu di sisi kiri.
Kemudian, ketik saja nama pengguna ke dalam kotak, dan klik ``Add collaborator.''
Anda dapat mengulangi ini sebanyak yang Anda inginkan untuk memberikan akses kepada semua orang yang Anda sukai.
Jika Anda perlu mencabut akses, klik saja ``X'' di sisi kanan baris itu.

.Repository collaborators.
image::images/collaborators.png[The repository collaborators box.]

==== Mengelola Pull Requests

Sekarang setelah Anda memiliki sebuah proyek dengan beberapa kode di dalamnya dan mungkin bahkan beberapa kolaborator yang juga memiliki akses push, mari kita membahas apa yang harus dilakukan saat Anda mendapatkan Pull Request.

Pull Request bisa berasal dari branch di fork repositori Anda atau branch lain di repositori yang sama. Perbedaannya adalah branch di fork biasanya berasal dari orang-orang dimana Anda tidak dapat melakukan push ke branch mereka dan mereka tidak dapat melakukan push ke branch Anda, sedangkan dengan Pull Request Internal umumnya, keduanya dapat mengakses branch tersebut.

Untuk contoh ini, mari kita anggap Anda adalah `tonychacon'' dan Anda telah membuat proyek kode Arudino baru yang bernama ``fade''.

[[_email_notifications]]
===== Notifikasi Surel

Seseorang bergabung dan membuat perubahan pada kode Anda dan mengirimkan Pull Request kepada Anda. Anda pasti mendapatkan surel yang memberi tahu Anda tentang Pull Request yang baru dan seharusnya terlihat seperti <<_email_pr>>.

[[_email_pr]]
.Email notification of a new Pull Request.
image::images/maint-01-email.png[Pull Request email notification]

Ada beberapa hal yang harus diperhatikan mengenai surel ini. Ini akan memberi Anda diffstat pendek -- sebuah daftar berkas yang telah berubah dan seberapa banyak berubahnya di Pull Request tersebut. Ini memberikan Anda tautan ke Pull Request pada GitHub. Ini juga memberikan Anda beberapa URL yang dapat Anda gunakan dari baris perintah.

Jika Anda melihat baris yang mengatakan `git pull <url> patch-1`, ini adalah cara mudah untuk melakukan merge branch remote tanpa harus menambahkan remote. Kita membahasnya dengan cepat di <<_checking_out_remotes>>. Jika Anda mau, Anda dapat membuat dan beralih ke branch topik dan kemudian menjalankan perintah ini untuk di-merge-kan dalam perubahan Pull Request.

URL menarik lainnya adalah URL `.diff` dan `.patch`, yang mungkin Anda duga, menyediakan versi diff dan patch terpadu dari Pull Request. Anda dapat melakukan merge secara teknis pekerjaan Pull Request dengan hal seperti ini:

[source,shell]
----
$ curl http://github.com/tonychacon/fade/pull/1.patch | git am
----

===== Berkolaborasi di Pull Request

Seperti yang kita bahas di <<_github_flow>>, Anda sekarang bisa melakukan percakapan dengan orang yang membuka Pull Request. Anda dapat mengomentari baris kode tertentu, mengomentari keseluruhan commit atau mengomentari seluruh Pull Request itu sendiri, dengan menggunakan GitHub Flavoured Markdown di mana-mana.

Setiap kali orang lain berkomentar mengenai Pull Request Anda akan terus mendapatkan notifikasi surel sehingga Anda tahu ada aktivitas yang sedang terjadi. Mereka masing-masing akan memiliki tautan ke Pull Request di mana aktivitas itu terjadi dan Anda juga dapat langsung menanggapi surel untuk memberi komentar pada thread Pull Request.

.Responses to emails are included in the thread.
image::images/maint-03-email-resp.png[Email response]

Setelah kode berada di tempat yang Anda suka dan ingin melakukan merge, Anda dapat melakukan pull kode ke bawah dan me-merge-kannya secara lokal, dengan sintaks `git pull <url> <branch>` yang telah kita lihat sebelumnya, atau dengan menambahkan fork sebagai remote dan pengambilan dan melakukan merge.

Jika ingin merge yang mudah, Anda cukup menekan tombol ``Merge'' di situs GitHub. Ini akan melakukan merge ``non-fast-forward'', membuat commit merge bahkan jika merge cepat mungkin diteruskan. Ini berarti dalam keadaan apapun, setiap kali Anda menekan tombol merge, sebuah commit merge dibuat. Seperti yang bisa Anda lihat di <<_merge_button>>, GitHub memberi Anda semua informasi ini jika Anda mengklik tautan petunjuknya.

[[_merge_button]]
.Merge button and instructions for merging a Pull Request manually.
image::images/maint-02-merge.png[Merge button]

Jika Anda memutuskan tidak ingin melakukan merge, Anda juga bisa menutup Pull Request dan orang yang membukanya akan diberitahu.

[[_pr_refs]]
===== Pull Request Refs

Jika Anda mempunyai *banyak* Pull Request dan tidak ingin menambahkan banyak remote atau satu kali melakukan pull setiap saat, ada trik bagus yang memungkinkan GitHub Anda lakukan. Trik ini adalah sedikit maju dan kita akan membahas rincian ini lebih banyak di <<_refspec>>, tapi ini dapat menjadi sangat berguna.

GitHub benar-benar mengiklankan branch Pull Request untuk repositori sebagai sejenis pseudo-branch di server. Secara default Anda tidak mendapatkannya ketika Anda mengkloning, tapi mereka berada di sana dengan cara yang tidak jelas dan Anda dapat mengaksesnya dengan mudah.

Untuk menunjukkan ini, kita akan menggunakan perintah tingkat-rendah (sering disebut sebagai perintah ``plumbing'', yang akan kita baca lebih lanjut di <<_plumbing_porcelain>>) yang disebut `ls-remote`. Perintah ini umumnya tidak digunakan dalam operasi Git sehari-hari namun berguna untuk menunjukkan kepada kita referensi apa yang ada di server.

Jika kita menjalankan perintah ini terhadap repositori ``blink'' yang kita gunakan sebelumnya, kita akan mendapatkan daftar semua branch dan tag dan referensi lainnya di repositori.

[source,shell]
----
$ git ls-remote https://github.com/schacon/blink
10d539600d86723087810ec636870a504f4fee4d	HEAD
10d539600d86723087810ec636870a504f4fee4d	refs/heads/master
6a83107c62950be9453aac297bb0193fd743cd6e	refs/pull/1/head
afe83c2d1a70674c9505cc1d8b7d380d5e076ed3	refs/pull/1/merge
3c8d735ee16296c242be7a9742ebfbc2665adec1	refs/pull/2/head
15c9f4f80973a2758462ab2066b6ad9fe8dcf03d	refs/pull/2/merge
a5a7751a33b7e86c5e9bb07b26001bb17d775d1a	refs/pull/4/head
31a45fc257e8433c8d8804e3e848cf61c9d3166c	refs/pull/4/merge
----

Tentu saja, jika Anda berada di repositori Anda dan Anda menjalankan `git ls-remote origin` atau remote yang ingin Anda periksa, itu akan menunjukkan sesuatu yang sama dengan ini.

Jika repositori itu berada di GitHub dan Anda memiliki Pull Requests yang telah dibuka, Anda akan mendapatkan referensi yang diawali dengan `refs/pull/`. Referensi ini pada dasarnya adalah branch-branch, tapi karena tidak berada di bawah `refs/heads/` Anda tidak mendapatkannya secara normal saat Anda mengkloning atau mengambil dari server -- proses pengambilan mengabaikannya secara normal.

Ada dua referensi per Pull Request - yang satu berakhir pada `/head` mengarahkan ke commit yang sama seperti commit terakhir di branch Pull Request. Jadi jika seseorang membuka Pull Request di repositori kita dan branch mereka diberi nama `bug-fix` dan mengarahkan ke commit `a5a775`, maka di repositori *our* kita tidak akan memiliki branch `bug-fix` branch (karena itu berada di fork mereka), tapi kita _akan_ memiliki `pull/<pr#>/head` yang mengarahkan ke `a5a775`. Ini berarti kita dapat dengan mudah melakukan pull ke bawah setiap branch Pull Request dalam satu putaran tanpa harus menambahkan banyak remote.

Sekarang, Anda bisa melakukan sesuatu seperti mengambil referensi secara langsung.

[source,shell]
----
$ git fetch origin refs/pull/958/head
From https://github.com/libgit2/libgit2
 * branch            refs/pull/958/head -> FETCH_HEAD
----

Ini menginformasikan Git, ``Hubungkan ke remote `origin`, dan unduh ref yang bernama `refs/pull/958/head`.''
Git akan mengikuti dan mengunduh semua yang Anda butuhkan untuk membuat ref itu, dan meletakkan pointer ke commit yang Anda inginkan dibawah `.git/FETCH_HEAD`.
Anda dapat menggabungkannya dengan `git merge FETCH_HEAD` ike branch yang ingin Anda uji, tapi pesan commit merga akan sedikit aneh.

Begitu juga, jika Anda meninjau *banyak* pull request, ini menjadi lama.

There's also a way to fetch _all_ of the pull requests, and keep them up to date whenever you connect to the remote.
Open up `.git/config` in your favorite editor, and look for the `origin` remote.
It should look a bit like this:

----
[remote "origin"]
    url = https://github.com/libgit2/libgit2
    fetch = +refs/heads/*:refs/remotes/origin/*
----

That line that begins with `fetch =` is a ``refspec.''
It's a way of mapping names on the remote with names in your local `.git` directory.
This particular one tells Git, "the things on the remote that are under `refs/heads` should go in my local repository under `refs/remotes/origin`."
You can modify this section to add another refspec:

----
[remote "origin"]
    url = https://github.com/libgit2/libgit2.git
    fetch = +refs/heads/*:refs/remotes/origin/*
    fetch = +refs/pull/*/head:refs/remotes/origin/pr/*
----

That last line tells Git, ``All the refs that look like `refs/pull/123/head` should be stored locally like `refs/remotes/origin/pr/123`.''
Now, if you save that file, and do a `git fetch`:

[source,shell]
----
$ git fetch
# …
 * [new ref]         refs/pull/1/head -> origin/pr/1
 * [new ref]         refs/pull/2/head -> origin/pr/2
 * [new ref]         refs/pull/4/head -> origin/pr/4
# …
----

Now all of the remote pull requests are represented locally with refs that act much like tracking branches; they're read-only, and they update when you do a fetch.
This makes it super easy to try the code from a pull request locally:

[source,shell]
----
$ git checkout pr/2
Checking out files: 100% (3769/3769), done.
Branch pr/2 set up to track remote branch pr/2 from origin.
Switched to a new branch 'pr/2'
----

The eagle-eyed among you would note the `head` on the end of the remote portion of the refspec.
There's also a `refs/pull/#/merge` ref on the GitHub side, which represents the commit that would result if you push the ``merge'' button on the site. This can allow you to test the merge before even hitting the button.


===== Pull Requests on Pull Requests

Not only can you open Pull Requests that target the main or `master` branch, you can actually open a Pull Request targeting any branch in the network. In fact, you can even target another Pull Request.

If you see a Pull Request that is moving in the right direction and you have an idea for a change that depends on it or you're not sure is a good idea, or you just don't have push access to the target branch, you can open a Pull Request directly to it.

When you go to open a Pull Request, there is a box at the top of the page that specifies which branch you're requesting to pull to and which you're requesting to pull from. If you hit the ``Edit'' button at the right of that box you can change not only the branches but also which fork.

[[_pr_targets]]
.Manually change the Pull Request target fork and branch.
image::images/maint-04-target.png[PR targets]

Here you can fairly easily specify to merge your new branch into another Pull Request or another fork of the project.

==== Mentions and Notifications

GitHub also has a pretty nice notifications system built in that can come in handy when you have questions or need feedback from specific individuals or teams.

In any comment you can start typing a `@` character and it will begin to autocomplete with the names and usernames of people who are collaborators or contributors in the project.

.Start typing @ to mention someone.
image::images/maint-05-mentions.png[Mentions]

You can also mention a user who is not in that dropdown, but often the autocompleter can make it faster.

Once you post a comment with a user mention, that user will be notified. This means that this can be a really effective way of pulling people into conversations rather than making them poll. Very often in  Pull Requests on GitHub people will pull in other people on their teams or in their company to review an Issue or Pull Request.

If someone gets mentioned on a Pull Request or Issue, they will be ``subscribed'' to it and will continue getting notifications any time some activity occurs on it. You will also be subscribed to something if you opened it, if you're watching the repository or if you comment on something. If you no longer wish to receive notifications, there is an ``Unsubscribe'' button on the page you can click to stop receiving updates on it.

.Unsubscribe from an Issue or Pull Request.
image::images/maint-06-unsubscribe.png[Unsubscribe]

===== The Notifications Page

When we mention ``notifications'' here with respect to GitHub, we mean a specific way that GitHub tries to get in touch with you when events happen and there are a few different ways you can configure them.
If you go to the ``Notification center'' tab from the settings page, you can see some of the options you have.

.Notification center options.
image::images/maint-07-notifications.png[Notifiation center]

The two choices are to get notifications over ``Email'' and over ``Web'' and you can choose either, niether or both for when you actively participate in things and for activity on repositories you are watching.

====== Web Notifications

Web notifications only exist on GitHub and you can only check them on GitHub. If you have this option selected in your preferences and a notification is triggered for you, you will see a small blue dot over your notifications icon at the top of your screen as seen in <<_not_center>>.

[[_not_center]]
.Notification center.
image::images/maint-08-notifications-page.png[Notifiation center]

If you click on that, you will see a list of all the items you have been notified about, grouped by project. You can filter to the notifications of a specific project by clicking on it's name in the left hand sidebar. You can also acknowledge the notifiction by clicking the checkmark icon next to any notification, or acknowledge _all_ of the notifictions in a project by clicking the checkmark at the top of the group. There is also a mute button next to each checkmark that you can click to not receive any further notifications on that item.

All of these tools are very useful for handling large numbers of notifications. Many GitHub power users will simply turn off email notifications entirely and manage all of their notifications through this screen.

====== Email Notifications

Email notifications are the other way you can handle notifications through GitHub. If you have this turned on you will get emails for each notification. We saw examples of this in <<_email_notification>> and <<_email_pr>>. The emails will also be threaded properly, which is nice if you're using a threading email client.

There is also a fair amount of metadata embedded in the headers of the emails that GitHub sends you, which can be really helpful for setting up custom filters and rules.

For instance, if we look at the actual email headers sent to Tony in the email shown in <<_email_pr>>, we will see the following among the information sent:

[source,mbox]
----
To: tonychacon/fade <fade@noreply.github.com>
Message-ID: <tonychacon/fade/pull/1@github.com>
Subject: [fade] Wait longer to see the dimming effect better (#1)
X-GitHub-Recipient: tonychacon
List-ID: tonychacon/fade <fade.tonychacon.github.com>
List-Archive: https://github.com/tonychacon/fade
List-Post: <mailto:reply+i-4XXX@reply.github.com>
List-Unsubscribe: <mailto:unsub+i-XXX@reply.github.com>,...
X-GitHub-Recipient-Address: tchacon@example.com
----

There are a couple of interesting things here. If you want to highlight or re-route emails to this particular project or even Pull Request, the information in `Message-ID` gives you all the data in `<user>/<project>/<type>/<id>` format. If this were an issue, for example, the `<type>` field would have been ``issues'' rather than ``pull''.

The `List-Post` and `List-Unsubscribe` fields mean that if you have a mail client that understands those, you can easily post to the list or ``Unsubscribe'' from the thread. That would be essentially the same as clicking the ``mute'' button on the web version of the notification or ``Unsubscribe'' on the Issue or Pull Request page itself.

It's also worth noting that if you have both email and web notifications enabled and you read the email version of the notification, the web version will be marked as read as well if you have images allowed in your mail client.

==== Special Files

There are a couple of special files that GitHub will notice if they are present in your repository.

==== README

The first is the `README` file, which can be of nearly any format that GitHub recognizes as prose. For example, it could be `README`, `README.md`, `README.asciidoc`, etc. If GitHub sees a README file in your source, it will render it on the landing page of the project.

Many teams use this file to hold all the relevant project information for someone who might be new to the repository or project. This generally includes things like:

* What the project is for
* How to configure and install it
* An example of how to use it or get it running
* The license that the project is offered under
* How to contribute to it

Since GitHub will render this file, you can embed images or links in it for added ease of understanding.

==== CONTRIBUTING

The other special file that GitHub recognizes is the `CONTRIBUTING` file. If you have a file named `CONTRIBUTING` with any file extension, GitHub will show <<_contrib_file>> when anyone starts opening a Pull Request.

[[_contrib_file]]
.Opening a Pull Request when a CONTRIBUTING file exists.
image::images/maint-09-contrib.png[Contributing notice]

The idea here is that you can specify specific things you want or don't want in a Pull Request sent to your project. This way people may actually read the guidelines before opening the Pull Request.

==== Project Administration

Generally there are not a lot of administrative things you can do with a single project, but there are a couple of items that might be of interest.

===== Changing the Default Branch

If you are using a branch other than ``master'' as your default branch that you want people to open Pull Requests on or see by default, you can change that in your repository's settings page under the ``Options'' tab.

[[_default_branch]]
.Change the default branch for a project.
image::images/maint-10-default-branch.png[Default branch]

Simply change the default branch in the dropdown and that will be the default for all major operations from then on, including which branch is checked out by default when someone clones the repository.

===== Transferring a Project

If you would like to transfer a project to another user or an organization in GitHub, there is a ``Transfer ownership'' option at the bottom of the same ``Options'' tab of your repository settings page that allows you to do this.

[[_transfer_project]]
.Transfer a project to anther GitHub user or Organization.
image::images/maint-11-transfer.png[Transfer]

This is helpful if you are abandoning a project and someone wants to take it over, or if your project is getting bigger and want to move it into an organization.

Not only does this move the repository along with all it's watchers and stars to another place, it also sets up a redirect from your URL to the new place. It will also redirect clones and fetches from Git, not just web requests.
