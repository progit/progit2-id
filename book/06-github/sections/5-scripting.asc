=== Menaskahkan GitHub

Jadi, sekarang kami telah membahas semua fitur dan alur kerja GitHub utama, namun setiap kelompok besar atau proyek akan memiliki penyesuaian yang mungkin ingin mereka lakukan atau layanan eksternal yang mungkin ingin mereka integrasikan.

Beruntung bagi kami, GitHub benar-benar bisa di-hack dengan berbagai cara. Pada bagian ini kita akan membahas bagaimana menggunakan sistem pengait GitHub dan API yang membuat GitHub bekerja sesuai keinginan kita.

==== Kaitan

Bagian Kaitan dan Layanan dari administrasi repositori GitHub adalah cara termudah untuk mengaktifkan GitHub dengan sistem eksternal.

Layanan =====

Pertama, kita akan lihat Layanan. Baik integrasi Kaitan dan Layanan dapat ditemukan di bagian Pengaturan pada repositori Anda, tempat kami sebelumnya melihat di Tambahkan Kolaborator dan mengubah cabang default proyek Anda. Di bawah tab ``Situs kaitan dan Layanan'' Anda akan melihat sesuatu seperti <<_services_hooks>>.

[[_kaitan_layanan]]
.Layanan dan bagian konfigurasi Kaitan.
Gambar::images/scripting-01-services.png[Layanan dan Kaitan]

Ada puluhan layanan yang dapat Anda pilih, sebagian besar merupakan integrasi ke komersial dan sistem open source lainnya. Kebanyakan dari mereka adalah untuk layanan Integrasi berkelanjutan, pelacak bug dan isu, sistem chat room dan sistem dokumentasi. Kita akan berjalan melalui pengaturan yang sangat sederhana, kaitan Email. Jika Anda memilih ``Email'' dari dropdown ``Tambah Layanan'', Anda akan mendapatkan layar konfigurasi seperti <<_service_config>>.

[[_service_config]]
.Konfigurasi layanan email.
gambar::images/scripting-02-email-service.png[Email service]

Dalam kasus ini, jika kami menekan tombol ``Tambahkan layanan'', alamat email yang kami tentukan akan mendapatkan email setiap kali seseorang mendorong ke repositori. Layanan dapat mendengarkan berbagai jenis acara berbeda, namun sebagian besar hanya mendengarkan acara push dan kemudian melakukan sesuatu dengan data tersebut.

Jika disana ada sistem yang Anda gunakan yang ingin Anda integrasikan dengan GitHub, anda harus memeriksa di sini untuk melihat apakah ada integrasi layanan yang tersedia. Sebagai contoh, jika Anda menggunakan Jenkins untuk menjalankan tes pada basis kode Anda, Anda dapat mengaktifkan integrasi layanan Jenkins builtin untuk memulai uji coba setiap kali seseorang mendorong ke repositori Anda.

===== Kaitan

Jika Anda memerlukan sesuatu yang lebih spesifik atau Anda ingin berintegrasi dengan layanan atau situs yang tidak termasuk dalam daftar ini, Sebagai gantinya anda bisa menggunakan sistem kaitan yang lebih umum. Kaitan repositori GitHub cukup sederhana. Anda menentukan URL dan GitHub akan mengirimkan muatan HTTP ke URL tersebut pada acara apa pun yang Anda inginkan.

Secara umum cara ini bekerja adalah anda bisa mempersiapkan layanan web kecil untuk mendengarkan muatan kaitan GitHub dan kemudian melakukan sesuatu dengan data saat diterima.

Untuk mengaktifkan kaitan, Anda klik tombol ``Tambahkan kaitan web'' di <<_services_hooks>>. Ini akan membawa Anda ke halaman yang terlihat seperti <<_web_hook>>.

[[_web_hook]]
.Konfigurasi kaitan web.
gambar::images/scripting-03-webhook.png[Kaitan web]

Konfigurasi untuk kaitan web cukup sederhana. Dalam kebanyakan kasus, Anda cukup memasukkan URL dan kunci rahasia dan tekan ``Tambahkan kaitan web''. Ada beberapa pilihan untuk acara yang Anda ingin GitHub mengirimkan muatan kepada Anda -- defaultnya adalah hanya mendapatkan muatan untuk acara `push`, bila seseorang mendorong kode baru ke cabang repositori Anda.

Mari kita lihat contoh kecil dari layanan web yang mungkin Anda siapkan untuk menangani kaitan web. Kami akan menggunakan kerangka web Ruby Sinatra karena ini cukup ringkas dan Anda harus dapat dengan mudah melihat apa yang sedang kami lakukan.

Katakanlah kami ingin mendapatkan email jika ada orang tertentu yang masuk ke cabang proyek kami yang spesifik yang memodifikasi file tertentu. Kita bisa dengan mudah melakukannya dengan kode seperti ini:

[sumber,ruby]
----
memerlukan 'sinatra'
memerlukan 'json'
memerlukan 'mail'

kiriman '/muatan' do
  push = JSON.parse(permintaan.tubuh.baca) # parse the JSON

  # kumpulann data yang kami cari
  pendorong = push["pendorong"]["nama"]
  cabang = push["ref"]

  # Dapatkan daftar semua file yang disentuh
  berkas = push["melakukan"].map do |melakukan|
    melakukan['ditambahkan'] + melakukan['dimodifikasi'] + melakukan['dihapus']
  akhir
  berkas = berkas.meratakan.uniq

  # Periksa kriteria kami
  jika pendorong == 'schacon' &&
     cabang == 'ref/heads/special-branch' &&
     berkas.termasuk?('special-file.txt')

    Surat.kirim
      dari     'tchacon@example.com'
      ke       'tchacon@example.com'
      subjek  'Scott Changed the File'
      isi     "ALARM"
    penutup
  penutup
penutup
----

Di sini kami mengambil muatan JSON yang diberikan GitHub dan melihat ke atas siapa yang mendorongnya, cabang apa yang mereka dorong dan file apa yang tersentuh dalam semua komit yang didorong. Kemudian kami memeriksa itu dengan kriteria kami dan mengirim email jika cocok.

Untuk mengembangkan dan menguji sesuatu seperti ini, Anda memiliki konsol pengembang yang bagus di layar yang sama di mana Anda mengatur Kaitan. Anda dapat melihat beberapa pengiriman terakhir yang telah coba dibuat GitHub untuk kaitan web itu. Untuk setiap kaitan Anda bisa menggali ke dalam saat itu dikirimkan, jika berhasil dan tubuh dan header untuk kedua permintaan dan responnya. Hal ini membuat sangat mudah untuk menguji dan debug kaitan Anda.

[[_web_hook_debug]]
.Informasi debugging kaitan web.
gambar::images/scripting-04-webhook-debug.png[kaitan web debug]

Fitur hebat lainnya dari ini adalah Anda dapat mengirim kembali muatan apa pun untuk menguji layanan Anda dengan mudah.

Untuk informasi lebih lanjut tentang cara menulis kaitan web dan semua jenis acara yang berbeda yang dapat Anda dengarkan, kunjungi dokumentasi Pengembang GitHub di: https://developer.github.com/webhooks/

==== API GitHub

(((API, GitHub)))
Layanan dan kaitan memberi Anda cara untuk menerima notifikasi push tentang kejadian yang terjadi di repositori Anda, namun jika Anda memerlukan lebih banyak informasi tentang acara ini? Bagaimana jika Anda perlu mengotomatisasi sesuatu seperti menambahkan kolaborator atau masalah pelabelan?

Di sinilah API GitHub sangat berguna. GitHub memiliki banyak titik akhir API untuk melakukan hampir semua hal yang dapat Anda lakukan di situs web secara otomatis. Pada bagian ini kita akan belajar bagaimana melakukan otentikasi dan koneksi ke API, bagaimana mengomentari sebuah masalah dan bagaimana mengubah status Pull Request melalui API.

==== Penggunaan Dasar

Hal paling mendasar yang dapat Anda lakukan adalah permintaan GET sederhana pada titik akhir yang tidak memerlukan otentikasi. Ini bisa menjadi informasi pengguna atau hanya dibaca pada proyek open source. Sebagai contoh, jika kami ingin tahu lebih banyak tentang pengguna bernama ``schacon'', kita bisa menjalankan sesuatu seperti ini:

[sumber,javascript]
----
$ curl https://api.github.com/users/schacon
{
  "login": "schacon",
  "id": 70,
  "avatar_url": "https://avatars.githubusercontent.com/u/70",
# â€¦
  "name": "Scott Chacon",
  "company": "GitHub",
  "following": 19,
  "created_at": "2008-01-27T17:19:28Z",
  "updated_at": "2014-06-10T02:37:23Z"
}
----

Ada banyak titik akhir seperti ini untuk mendapatkan informasi tentang organisasi, proyek, isu, komit -- apa saja yang dapat Anda lihat secara publik di GitHub. Anda bahkan dapat menggunakan API untuk membuat ganti rugi sewenang-wenang atau menemukan template `.gitignore`.

[sumber,javascript]
----
$ curl https://api.github.com/gitignore/templates/Java
{
  "nama": "Java",
  "sumber": "*.kelas

# Alat Mobile untuk Java (J2ME)
.mtj.tmp/

# Paket Berkas #
*.jar
*.war
*.ear

# log kecelakaan mesin virtual, lihat http://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*
"
}
----


==== Mengomentari sebuah Isu

Namun, jika Anda ingin untuk melakukan tindakan di situs web seperti memberi komentar pada Masalah atau Pull Request atau jika Anda ingin melihat atau berinteraksi dengan konten pribadi, Anda harus melakukan otentikasi.

Ada beberapa cara untuk melakukan otentikasi. Anda bisa menggunakan otentikasi dasar hanya dengan nama pengguna dan kata sandi anda, namun umumnya ide yang lebih baik untuk menggunakan token akses pribadi.
Anda dapat membuat ini dari tab ``Aplikasi'' pada halaman pengaturan Anda.

[[_akses_token]]
.Buat akses token anda dari tab ``Aplikasi'' pada halaman pengaturan Anda.
image::images/scripting-05-access-token.png[Access Token]

Ini akan menanyakan cakupan mana yang Anda inginkan untuk token dan deskripsi ini. Pastikan untuk menggunakan deskripsi yang bagus sehingga Anda merasa nyaman menghapus token saat naskah atau aplikasi Anda tidak lagi digunakan.

GitHub hanya akan menunjukkan token Anda sekali, jadi pastikan untuk menyalinnya. Anda sekarang dapat menggunakan ini untuk melakukan otentikasi dalam naskah Anda sebagai ganti menggunakan nama pengguna dan kata sandi. Ini bagus karena Anda bisa membatasi ruang lingkup dari apa yang ingin Anda lakukan dan token itu bisa dicontoh.

Ini juga memiliki keuntungan tambahan untuk meningkatkan batas tingkat Anda. Tanpa melakukan otentikasi, Anda akan dibatasi hingga 60 permintaan per jam. Jika Anda mengotentikasi Anda dapat membuat hingga 5.000 permintaan per jam.

Jadi mari kita gunakan itu untuk memberi komentar pada salah satu masalah kami. Katakanlah kita ingin meninggalkan komentar mengenai isu tertentu, Edisi #6. Untuk melakukannya, kami harus melakukan permintaan HTTP POST untuk `repos/<pengguna>/<repo>/masalah/<num>/komentar` dengan token yang baru kami buat sebagai header Otorisasi.

[sumber,javascript]
----
$ curl -H "Jenis-konten: aplikasi/json" \
       -H "Otorisasi: token TOKEN" \
       --berkas '{"isi":"Komentar baru, :+1:"}' \
       https://api.github.com/repos/schacon/blink/issues/6/comments
{
  "id": 58322100,
  "html_url": "https://github.com/schacon/blink/issues/6#issuecomment-58322100",
  ...
  "penggunar": {
    "Masuk": "tonychacon",
    "id": 7874698,
    "avatar_url": "https://avatars.githubusercontent.com/u/7874698?v=2",
    "jenis": "Pengguna",
  },
  "created_at": "2014-10-08T07:48:19Z",
  "updated_at": "2014-10-08T07:48:19Z",
  "body": "A new comment, :+1:"
}
----

Now if you go to that issue, you can see the comment that we just successfully posted as in <<_api_comment>>.

[[_api_comment]]
.A comment posted from the GitHub API.
image::images/scripting-06-comment.png[API Comment]

You can use the API to do just about anything you can do on the website -- creating and setting milestones, assigning people to Issues and Pull Requests, creating and changing labels, accessing commit data, creating new commits and branches, opening, closing or merging Pull Requests, creating and editing teams, commenting on lines of code in a Pull Request, searching the site and on and on.

==== Changing the Status of a Pull Request

One final example we'll look at since it's really useful if you're working with Pull Requests. Each commit can have one or more statuses associated with it and there is an API to add and query that status.

Most of the Continuous Integration and testing services make use of this API to react to pushes by testing the code that was pushed, and then report back if that commit has passed all the tests. You could also use this to check if the commit message is properly formatted, if the submitter followed all your contribution guidelines, if the commit was validly signed -- any number of things.

Let's say you set up a webhook on your repository that hits a small web service that checks for a `Signed-off-by` string in the commit message.

[source,ruby]
----
require 'httparty'
require 'sinatra'
require 'json'

post '/payload' do
  push = JSON.parse(request.body.read) # parse the JSON
  repo_name = push['repository']['full_name']

  # look through each commit message
  push["commits"].each do |commit|

    # look for a Signed-off-by string
    if /Signed-off-by/.match commit['message']
      state = 'success'
      description = 'Successfully signed off!'
    else
      state = 'failure'
      description = 'No signoff found.'
    end

    # post status to GitHub
    sha = commit["id"]
    status_url = "https://api.github.com/repos/#{repo_name}/statuses/#{sha}"

    status = {
      "state"       => state,
      "description" => description,
      "target_url"  => "http://example.com/how-to-signoff",
      "context"     => "validate/signoff"
    }
    HTTParty.post(status_url,
      :body => status.to_json,
      :headers => {
        'Content-Type'  => 'application/json',
        'User-Agent'    => 'tonychacon/signoff',
        'Authorization' => "token #{ENV['TOKEN']}" }
    )
  end
end
----

Hopefully this is fairly simple to follow. In this web hook handler we look through each commit that was just pushed, we look for the string 'Signed-off-by' in the commit message and finally we POST via HTTP to the `/repos/<user>/<repo>/statuses/<commit_sha>` API endpoint with the status.

In this case you can send a state ('success', 'failure', 'error'), a description of what happened, a target URL the user can go to for more information and a ``context'' in case there are multiple statuses for a single commit. For example, a testing service may provide a status and a validation service like this may also provide a status -- the ``context'' field is how they're differentiated.

If someone opens a new Pull Request on GitHub and this hook is setup, you may see something like <<_commit_status>>.

[[_commit_status]]
.Commit status via the API.
image::images/scripting-07-status.png[Commit status]

You can now see a little green check mark next to the commit that has a ``Signed-off-by'' string in the message and a red cross through the one where the author forgot to sign off. You can also see that the Pull Request takes the status of the last commit on the branch and warns you if it is a failure. This is really useful if you're using this API for test results so you don't accidentally merge something where the last commit is failing tests.

==== Octokit

Though we've been doing nearly everything through `curl` and simple HTTP requests in these examples, several open-source libraries exist that make this API available in a more idiomatic way.
At the time of this writing, the supported languages include Go, Objective-C, Ruby, and .NET.
Check out http://github.com/octokit[] for more information on these, as they handle much of the HTTP for you.

Hopefully these tools can help you customize and modify GitHub to work better for your specific workflows.
For complete documentation on the entire API as well as guides for common tasks, check out https://developer.github.com[].
